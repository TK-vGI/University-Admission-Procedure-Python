def print_output(departments: dict) -> None:
    for dept in sorted(departments.keys()):
        print(dept)
        for name, gpa, *_ in departments[dept]:
            print(f"{name} {gpa:.2f}")
        print()


def print_output_to_file(departments: dict):
    with open("admitted.txt", "w", encoding="utf-8") as fd:
        for dept in sorted(departments.keys()):
            fd.write(dept + "\n")
            for name, gpa, *_ in departments[dept]:
                line = f"{name} {gpa:.2f}"
                fd.write(line + "\n")
            fd.write("\n")


def sort_by_gpa(applicants: list) -> list:  # calculate Grade Point Average
    sorted_by_gpa = sorted(applicants, key=lambda x: (-x[1], x[0]))
    return sorted_by_gpa


def process_file() -> list:
    applicants = []
    # Read the applicants.txt file, example: "Laura Spungen 3.71 Physics Engineering Mathematics"
    with open("applicants.txt", "r", encoding="utf-8") as fd:
        lines = fd.readlines()
        for line in lines:
            line_ = line.strip().split(' ')
            name = " ".join(line_[0:2])
            gpa = float(line_[2])
            choice_a = line_[3]
            choice_b = line_[4]
            choice_c = line_[5]
            applicants.append([name, gpa, choice_a, choice_b, choice_c])

    return applicants


def sort_by_department(applicants: list, departments: dict, n: int) -> dict:
    # Track applicants who have already been admitted
    admitted = set()

    # Round indices for priority departments
    priorities = [2, 3, 4]  # first, second, third priority

    for priority in priorities:
        for dept in departments:
            # Only consider applicants who are not admitted yet
            eligible = [
                applicant for applicant in applicants
                if applicant[priority] == dept and tuple(applicant) not in admitted
            ]

            # # Debug
            # print("Debug:")
            # for a in eligible:
            #     print(f"{a[0]} - {a[1]:.2f} - Round {priority - 1} for {dept}")

            # Sort by GPA (descending), if equal then by name (ascending)
            eligible.sort(key=lambda x: (-x[1], x[0]))

            # Calculate remaining seats for department
            seats_left = n - len(departments[dept])
            selected = eligible[:seats_left]

            # Add selected to department and mark as admitted
            departments[dept].extend(selected)
            admitted.update(map(tuple, selected))  # convert to tuple to make hashable

    # Re-sort each department's final list before returning
    for dept in departments:
        departments[dept].sort(key=lambda x: (-x[1], x[0]))

    return departments


def main():
    departments = {dept: [] for dept in ["Biotech", "Chemistry", "Engineering", "Mathematics", "Physics"]}

    # Process "applicants.txt" file, example: "Laura Spungen 3.71 Physics Engineering Mathematics"
    applicants = process_file()
    # # Debug
    # print("Debug - unsorted applicants:")
    # for name, grade, a, b, c in total_applicants:
    #     print(f"{name}, {grade:.2f}, {a}, {b}, {c}")

    # N integer representing the number of applicants allowed for department
    n = int(input())

    # Sort applicants by GPA (descending), if equal then by name (ascending)
    sorted_applicants_gpa = sort_by_gpa(applicants)

    # Sort list of applicant by Departments
    departments = sort_by_department(sorted_applicants_gpa, departments, n)

    # Output result according to score
    # print_output_to_file(departments)
    print_output(departments)


if __name__ == '__main__':
    main()
